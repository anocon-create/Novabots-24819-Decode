package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;

import com.pedropathing.drive.MecanumDrive;
import com.pedropathing.localization.Pose;
import com.pedropathing.pathgeneration.Path;
import com.pedropathing.pathgeneration.PathBuilder;

import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.util.ElapsedTime;

@Autonomous(name="Red Far PP Auton", group="Linear")
public class RedFarPPAuton extends LinearOpMode {

    private MecanumDrive drive;

    // Drive motors
    private DcMotor frontLeft, frontRight, backLeft, backRight;

    // Intake motors
    private DcMotor intake1, intake2;

    // Flywheels (MUST be DcMotorEx for velocity)
    private DcMotorEx flywheelLeft, flywheelRight;

    // Full RPM for shooting
    private final double FULL_SPEED_RPM = 4500;

    @Override
    public void runOpMode() throws InterruptedException {

        // ============================================================
        // HARDWARE MAP — PLACEHOLDER "port" (you will rename later)
        // ============================================================
        frontLeft  = hardwareMap.get(DcMotor.class, "port");
        frontRight = hardwareMap.get(DcMotor.class, "port");
        backLeft   = hardwareMap.get(DcMotor.class, "port");
        backRight  = hardwareMap.get(DcMotor.class, "port");

        intake1 = hardwareMap.get(DcMotor.class, "port");
        intake2 = hardwareMap.get(DcMotor.class, "port");

        flywheelLeft  = hardwareMap.get(DcMotorEx.class, "port");
        flywheelRight = hardwareMap.get(DcMotorEx.class, "port");

        // ============================================================
        // MOTOR DIRECTIONS
        // ============================================================
        frontRight.setDirection(DcMotor.Direction.REVERSE);
        backRight.setDirection(DcMotor.Direction.REVERSE);

        // Same as TeleOp: intake reversed
        intake1.setDirection(DcMotor.Direction.REVERSE);
        intake2.setDirection(DcMotor.Direction.REVERSE);

        flywheelRight.setDirection(DcMotor.Direction.REVERSE);

        // ============================================================
        // ZERO POWER BEHAVIOR
        // ============================================================
        frontLeft.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);
        frontRight.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);
        backLeft.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);
        backRight.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);

        flywheelLeft.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        flywheelRight.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);

        intake1.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);
        intake2.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);

        // ============================================================
        // ENCODER MODE FOR FLYWHEELS
        // ============================================================
        flywheelLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        flywheelRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);

        // ============================================================
        // INITIALIZE PEDRO MECHANUM DRIVE
        // ============================================================
        drive = new MecanumDrive(frontLeft, frontRight, backLeft, backRight);

        drive.setPose(new Pose(60, -36, Math.toRadians(140)));

        telemetry.addLine("Red Far PP Auton READY");
        telemetry.update();

        waitForStart();
        if (isStopRequested()) return;

        // ------------------------------------------------------------
        // PRE-SPIN SHOOTER
        // ------------------------------------------------------------
        preSpinShooter();

        // ------------------------------------------------------------
        // SEQUENCE: Shoot → Intake → Shoot ... etc
        // ------------------------------------------------------------

        drive.followPath(splineShootFast());
        drive.followPath(preciseTurn(138));
        shootQuick();

        timedIntake(splineIntake1(), splineReturnShoot2());
        drive.followPath(preciseTurn(138));
        shootQuick();

        timedIntake(splineIntake2(), splineReturnShoot3());
        drive.followPath(preciseTurn(138));
        shootQuick();

        timedIntake(splineIntake3(), splineReturnShoot4());
        drive.followPath(preciseTurn(138));
        shootQuick();

        timedIntake(splineIntake4(), splineReturnShoot5());
        drive.followPath(preciseTurn(138));
        shootQuick();

        timedIntake(splineIntake5(), splineReturnShoot6());
        drive.followPath(preciseTurn(138));
        shootQuick();

        // ------------------------------------------------------------
        // PARK
        // ------------------------------------------------------------
        drive.followPath(splinePark());
    }

    // =====================================================================
    // TIMED INTAKE ALONG A PATH
    // =====================================================================
    private void timedIntake(Path intakePath, Path returnShootPath) {

        intake1.setPower(-1.0);
        intake2.setPower(-1.0);

        drive.followPath(intakePath);

        intake1.setPower(0);
        intake2.setPower(0);

        drive.followPath(returnShootPath);
    }

    // =====================================================================
    // SHOOTING HELPERS
    // =====================================================================
    private void preSpinShooter() {
        flywheelLeft.setVelocity(FULL_SPEED_RPM);
        flywheelRight.setVelocity(FULL_SPEED_RPM);
    }

    private void shootQuick() {
        ElapsedTime t = new ElapsedTime();

        intake1.setPower(-1.0);
        intake2.setPower(-1.0);

        while (opModeIsActive() && t.seconds() < 0.9) {}

        intake1.setPower(0);
        intake2.setPower(0);
    }

    // =====================================================================
    // PATHS (unchanged)
    // =====================================================================
    private Path splineShootFast() {
        return new PathBuilder(drive.getPose())
                .splineTo(22, 5, Math.toRadians(136))
                .build();
    }

    private Path splineIntake1() { return new PathBuilder(drive.getPose()).splineTo(44, -58, Math.toRadians(185)).build(); }
    private Path splineReturnShoot2() { return new PathBuilder(drive.getPose()).splineTo(23, 4, Math.toRadians(136)).build(); }

    private Path splineIntake2() { return new PathBuilder(drive.getPose()).splineTo(45, -60, Math.toRadians(185)).build(); }
    private Path splineReturnShoot3() { return new PathBuilder(drive.getPose()).splineTo(23, 5, Math.toRadians(135)).build(); }

    private Path splineIntake3() { return new PathBuilder(drive.getPose()).splineTo(46, -61, Math.toRadians(185)).build(); }
    private Path splineReturnShoot4() { return new PathBuilder(drive.getPose()).splineTo(23, 6, Math.toRadians(136)).build(); }

    private Path splineIntake4() { return new PathBuilder(drive.getPose()).splineTo(48, -62, Math.toRadians(185)).build(); }
    private Path splineReturnShoot5() { return new PathBuilder(drive.getPose()).splineTo(22, 6, Math.toRadians(135)).build(); }

    private Path splineIntake5() { return new PathBuilder(drive.getPose()).splineTo(50, -63, Math.toRadians(185)).build(); }
    private Path splineReturnShoot6() { return new PathBuilder(drive.getPose()).splineTo(22, 7, Math.toRadians(135)).build(); }

    private Path splinePark() { return new PathBuilder(drive.getPose()).splineTo(10, 60, Math.toRadians(90)).build(); }

    // =====================================================================
    // PRECISION TURN
    // =====================================================================
    private Path preciseTurn(double deg) {
        return new PathBuilder(drive.getPose())
                .turnTo(Math.toRadians(deg))
                .build();
    }
}
