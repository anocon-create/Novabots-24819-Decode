package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.Servo;

import org.firstinspires.ftc.vision.VisionPortal;
import org.firstinspires.ftc.vision.apriltag.AprilTagDetection;
import org.firstinspires.ftc.vision.apriltag.AprilTagProcessor;
import org.firstinspires.ftc.robotcore.external.hardware.camera.WebcamName;

@TeleOp(name = "AprilTag Servo Tracker (Auto Unwind)", group = "Vision")
public class AprilTagServoTrackerUnwind extends LinearOpMode {

    private Servo trackingServo;

    private VisionPortal visionPortal;
    private AprilTagProcessor aprilTag;

    private static final int TARGET_TAG_ID = 20;

    // Servo parameters
    private static final double SERVO_MIN = 0.0;
    private static final double SERVO_MAX = 180.0;
    private static final double SERVO_CENTER = 90.0;

    // How strongly yaw affects the servo
    private static final double YAW_GAIN = 1.0;

    // Virtual angle (can exceed 180)
    private double virtualAngle = SERVO_CENTER;

    @Override
    public void runOpMode() {

        trackingServo = hardwareMap.get(Servo.class, "trackingServo");

        aprilTag = AprilTagProcessor.easyCreateWithDefaults();
        visionPortal = VisionPortal.easyCreateWithDefaults(
                hardwareMap.get(WebcamName.class, "Webcam 1"),
                aprilTag
        );

        trackingServo.setPosition(degToServo(SERVO_CENTER));

        telemetry.addLine("AprilTag Servo Tracker (Auto Unwind) Ready");
        telemetry.update();

        waitForStart();

        while (opModeIsActive()) {

            AprilTagDetection target = null;

            for (AprilTagDetection detection : aprilTag.getDetections()) {
                if (detection.id == TARGET_TAG_ID) {
                    target = detection;
                    break;
                }
            }

            if (target != null) {

                double yaw = target.ftcPose.yaw;

                // Compute unbounded virtual angle
                virtualAngle = SERVO_CENTER + (yaw * YAW_GAIN);

                // Fold virtual angle into 0–180 range (triangle wave)
                double servoAngle = foldAngle(virtualAngle);

                trackingServo.setPosition(degToServo(servoAngle));

                telemetry.addLine("Tag Found");
                telemetry.addData("Yaw (deg)", yaw);
                telemetry.addData("Virtual Angle", virtualAngle);
                telemetry.addData("Servo Angle", servoAngle);

            } else {
                telemetry.addLine("Tag 20 not visible");
            }

            telemetry.update();
        }

        visionPortal.close();
    }

    // Converts degrees to servo position
    private double degToServo(double degrees) {
        return degrees / 180.0;
    }

    /**
     * Folds any angle into a 0–180° range while preserving direction.
     * This causes the servo to "unwind" instead of over-rotating.
     */
    private double foldAngle(double angle) {
        double wrapped = angle % 360.0;
        if (wrapped < 0) wrapped += 360.0;

        if (wrapped <= 180.0) {
            return wrapped;
        } else {
            return 360.0 - wrapped;
        }
    }
}
