package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorSimple;
import com.qualcomm.robotcore.hardware.Servo;

@Autonomous(name="Red Encoder Far Auton", group="Linear OpMode")
public class RedEncoderFarAuton extends LinearOpMode {

    // === Drive Motors ===
    private DcMotor frontLeftMotor;
    private DcMotor frontRightMotor;
    private DcMotor backLeftMotor;
    private DcMotor backRightMotor;

    // === Other Motors ===
    private DcMotor intake1;
    private DcMotor intake2;
    private DcMotor flywheelLeft;
    private DcMotor flywheelRight;

    // === Servo (Gate) ===
    private Servo myServo;
    private final double startPosition = 0.60; // gate closed
    private final double outPosition = 0.10;   // gate open

    // === Encoder / Drive Constants ===
    public static final double COUNTS_PER_REV = 580.4;
    public static final double WHEEL_DIAMETER_INCHES = 3.78;
    public static final double WHEEL_CIRCUMFERENCE = Math.PI * WHEEL_DIAMETER_INCHES;
    public static final double TICKS_PER_INCH = COUNTS_PER_REV / WHEEL_CIRCUMFERENCE;

    // === Flywheel Constants ===
    private final double FULL_SPEED_RPM = 1000;
    private final double HALF_SPEED_RPM = 850;

    @Override
    public void runOpMode() throws InterruptedException {

        // === Hardware Mapping ===
        frontLeftMotor  = hardwareMap.get(DcMotor.class, "portTwo");
        frontRightMotor = hardwareMap.get(DcMotor.class, "portTwoEXP");
        backLeftMotor   = hardwareMap.get(DcMotor.class, "portThree");
        backRightMotor  = hardwareMap.get(DcMotor.class, "portThreeEXP");
        intake1 = hardwareMap.get(DcMotor.class, "portZero");
        intake2 = hardwareMap.get(DcMotor.class, "portZeroEXP");
        flywheelLeft = hardwareMap.get(DcMotor.class, "portOne");
        flywheelRight = hardwareMap.get(DcMotor.class, "portOneEXP");
        myServo = hardwareMap.get(Servo.class, "servoFour");

        // === Set initial servo position ===
        myServo.setPosition(startPosition);

        // === Motor Directions ===
        frontRightMotor.setDirection(DcMotorSimple.Direction.REVERSE);
        backRightMotor.setDirection(DcMotorSimple.Direction.REVERSE);
        intake1.setDirection(DcMotorSimple.Direction.REVERSE);
        flywheelLeft.setDirection(DcMotorSimple.Direction.FORWARD);
        flywheelRight.setDirection(DcMotorSimple.Direction.REVERSE);

        // === Zero Power Behavior ===
        frontLeftMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        frontRightMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        backLeftMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        backRightMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        intake1.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);
        intake2.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);
        flywheelLeft.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        flywheelRight.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);

        // === Reset Encoders ===
        resetEncoders();

        // === Flywheels run using encoder for velocity control ===
        flywheelLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        flywheelRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);

        telemetry.addLine("READY");
        telemetry.update();

        waitForStart();
        if (isStopRequested()) return;

        // === AUTON SEQUENCE ===
        shootThreeArtifacts();

        TurnForAngle(-45, 0.5);
        strafeAndRotate(0.6, 0.3, 1.0);
        intakeBall();
        strafeAndRotate(-0.7, 0.3, 0.75);
        shootThreeArtifacts();
        strafeAndRotate(0.7, -0.6, 1.0);
        intakeBall();
        TurnForAngle(90, 0.7);
        driveForDistance(12, 0.6);
        strafeForDistance(18, 0.7, true);
        strafeAndRotate(-0.7, 0.6, 1.0);
        shootThreeArtifacts();
        strafeAndRotate(0.6, 0.5, 0.75);
        intakeBall();
        driveAndTurn(0.6, -0.5, 0.75);
        shootThreeArtifacts();
        TurnForAngle(30, 0.6);
        driveForDistance(36, 0.7);
        TurnForAngle(90, 0.6);
        intakeBall();
        strafeAndRotate(0.6, 0.6, 0.8);
        shootThreeArtifacts();
        strafeAndRotate(0.8, 0.6, 0.75);
        intakeBall();
        strafeAndRotate(0.6, 0.6, 0.8);
        shootThreeArtifacts();
        driveForDistance(36, 0.7);

        stopMotors();
    }

    // === Reset Encoders ===
    private void resetEncoders() {
        frontLeftMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        frontRightMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        backLeftMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        backRightMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);

        frontLeftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        frontRightMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        backLeftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        backRightMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    }

    // === Shoot 3 Artifacts with servo gate ===
    public void shootThreeArtifacts() {

        // 1. Spin up flywheels
        flywheelLeft.setVelocity(FULL_SPEED_RPM);
        flywheelRight.setVelocity(FULL_SPEED_RPM);

        // 2. Keep gate closed while spin-up
        myServo.setPosition(startPosition);
        sleep(1200); // adjust spin-up time as needed

        // 3. Open gate
        myServo.setPosition(outPosition);

        // 4. Feed 3 artifacts with intake
        for (int i = 0; i < 3; i++) {
            intake1.setPower(-0.9);
            intake2.setPower(-0.9);
            sleep(500); // time to feed one artifact
            intake1.setPower(0);
            intake2.setPower(0);
            sleep(150); // small delay between artifacts
        }

        // 5. Close gate
        myServo.setPosition(startPosition);

        // 6. Stop flywheels
        flywheelLeft.setVelocity(0);
        flywheelRight.setVelocity(0);
    }

    // === Intake ===
    public void intakeBall() {
        frontLeftMotor.setPower(-0.6);
        frontRightMotor.setPower(-0.6);
        backLeftMotor.setPower(-0.6);
        backRightMotor.setPower(-0.6);
        intake1.setPower(-0.8);
        intake2.setPower(-0.8);

        sleep(1000); // run intake while moving

        stopMotors();
        intake1.setPower(0);
        intake2.setPower(0);

        sleep(200);
    }

    // === Turn For Angle ===
    public void TurnForAngle(double angleDegrees, double power) {
        double TRACK_WIDTH = 21.3028;
        double turnInches = Math.PI * TRACK_WIDTH * (angleDegrees / 360.0);
        int ticks = (int)(turnInches * TICKS_PER_INCH);

        frontLeftMotor.setTargetPosition(frontLeftMotor.getCurrentPosition() + ticks);
        backLeftMotor.setTargetPosition(backLeftMotor.getCurrentPosition() + ticks);
        frontRightMotor.setTargetPosition(frontRightMotor.getCurrentPosition() - ticks);
        backRightMotor.setTargetPosition(backRightMotor.getCurrentPosition() - ticks);

        frontLeftMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        backLeftMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        frontRightMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        backRightMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);

        frontLeftMotor.setPower(power);
        backLeftMotor.setPower(power);
        frontRightMotor.setPower(power);
        backRightMotor.setPower(power);

        while (opModeIsActive() &&
               frontLeftMotor.isBusy() && frontRightMotor.isBusy() &&
               backLeftMotor.isBusy() && backRightMotor.isBusy()) {
            // wait
        }

        stopMotors();
    }

    // === Strafe and rotate (mecanum) ===
    public void strafeAndRotate(double x, double y, double turnPower) {
        double fl = y + x + turnPower;
        double fr = y - x - turnPower;
        double bl = y - x + turnPower;
        double br = y + x - turnPower;

        // normalize
        double max = Math.max(Math.max(Math.abs(fl), Math.abs(fr)), Math.max(Math.abs(bl), Math.abs(br)));
        if (max > 1.0) {
            fl /= max;
            fr /= max;
            bl /= max;
            br /= max;
        }

        frontLeftMotor.setPower(fl);
        frontRightMotor.setPower(fr);
        backLeftMotor.setPower(bl);
        backRightMotor.setPower(br);

        sleep( (long)(1000) ); // adjust time if needed
        stopMotors();
    }

    // === Drive straight with encoders ===
    public void driveForDistance(double inches, double power) {
        int targetTicks = (int)(inches * TICKS_PER_INCH);

        frontLeftMotor.setTargetPosition(frontLeftMotor.getCurrentPosition() + targetTicks);
        backLeftMotor.setTargetPosition(backLeftMotor.getCurrentPosition() + targetTicks);
        frontRightMotor.setTargetPosition(frontRightMotor.getCurrentPosition() + targetTicks);
        backRightMotor.setTargetPosition(backRightMotor.getCurrentPosition() + targetTicks);

        frontLeftMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        backLeftMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        frontRightMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        backRightMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);

        frontLeftMotor.setPower(power);
        frontRightMotor.setPower(power);
        backLeftMotor.setPower(power);
        backRightMotor.setPower(power);

        while (opModeIsActive() &&
               frontLeftMotor.isBusy() && frontRightMotor.isBusy() &&
               backLeftMotor.isBusy() && backRightMotor.isBusy()) {}

        stopMotors();
    }

    // === Strafe left/right with encoders ===
    public void strafeForDistance(double inches, double power, boolean right) {
        int targetTicks = (int)(inches * TICKS_PER_INCH);
        int dir = right ? 1 : -1;

        frontLeftMotor.setTargetPosition(frontLeftMotor.getCurrentPosition() + dir * targetTicks);
        backLeftMotor.setTargetPosition(backLeftMotor.getCurrentPosition() - dir * targetTicks);
        frontRightMotor.setTargetPosition(frontRightMotor.getCurrentPosition() - dir * targetTicks);
        backRightMotor.setTargetPosition(backRightMotor.getCurrentPosition() + dir * targetTicks);

        frontLeftMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        backLeftMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        frontRightMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        backRightMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);

        frontLeftMotor.setPower(power);
        frontRightMotor.setPower(power);
        backLeftMotor.setPower(power);
        backRightMotor.setPower(power);

        while (opModeIsActive() &&
               frontLeftMotor.isBusy() && frontRightMotor.isBusy() &&
               backLeftMotor.isBusy() && backRightMotor.isBusy()) {}

        stopMotors();
    }

    // === Drive and turn at same time ===
    public void driveAndTurn(double xPower, double turnPower, double duration) {
        double fl = xPower + turnPower;
        double fr = xPower - turnPower;
        double bl = xPower + turnPower;
        double br = xPower - turnPower;

        // normalize
        double max = Math.max(Math.max(Math.abs(fl), Math.abs(fr)), Math.max(Math.abs(bl), Math.abs(br)));
        if (max > 1.0) {
            fl /= max;
            fr /= max;
            bl /= max;
            br /= max;
        }

        frontLeftMotor.setPower(fl);
        frontRightMotor.setPower(fr);
        backLeftMotor.setPower(bl);
        backRightMotor.setPower(br);

        sleep((long)(duration * 1000));

        stopMotors();
    }

    // === Stop all drive motors ===
    public void stopMotors() {
        frontLeftMotor.setPower(0);
        frontRightMotor.setPower(0);
        backLeftMotor.setPower(0);
        backRightMotor.setPower(0);
    }
}
