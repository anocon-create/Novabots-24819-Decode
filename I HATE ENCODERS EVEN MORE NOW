package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorSimple;
import com.qualcomm.robotcore.util.ElapsedTime;

@Autonomous(name="Red Encoder Close Auton (Optimized)", group="Linear OpMode")
public class RedEncoderCloseAuton extends LinearOpMode {

    // === Drive Motors ===
    private DcMotor frontLeftMotor  = null;
    private DcMotor frontRightMotor = null;
    private DcMotor backLeftMotor   = null;
    private DcMotor backRightMotor  = null;
    private DcMotor intake1 = null;
    private DcMotor intake2 = null;
    private DcMotor flywheelLeft = null;
    private DcMotor flywheelRight = null;

    // === Encoder Constants (GoBILDA 5203-19:1) ===
    public static final double COUNTS_PER_REV = 580.4;
    public static final double WHEEL_DIAMETER_INCHES = 3.78;
    public static final double WHEEL_CIRCUMFERENCE = Math.PI * WHEEL_DIAMETER_INCHES;
    public static final double TICKS_PER_INCH = COUNTS_PER_REV / WHEEL_CIRCUMFERENCE;

    @Override
    public void runOpMode() throws InterruptedException {
        
        // === Hardware Map (unchanged, all "port") ===
        frontLeftMotor  = hardwareMap.get(DcMotor.class, "port");
        frontRightMotor = hardwareMap.get(DcMotor.class, "port");
        backLeftMotor   = hardwareMap.get(DcMotor.class, "port");
        backRightMotor  = hardwareMap.get(DcMotor.class, "port");
        intake1 = hardwareMap.get(DcMotor.class, "port");
        intake2 = hardwareMap.get(DcMotor.class, "port");
        flywheelLeft = hardwareMap.get(DcMotor.class, "port");
        flywheelRight = hardwareMap.get(DcMotor.class, "port");

        // === Directions ===
        frontRightMotor.setDirection(DcMotorSimple.Direction.REVERSE);
        backRightMotor.setDirection(DcMotorSimple.Direction.REVERSE);
        intake1.setDirection(DcMotorSimple.Direction.REVERSE);
        flywheelLeft.setDirection(DcMotorSimple.Direction.FORWARD);
        flywheelRight.setDirection(DcMotorSimple.Direction.REVERSE);

        // === Zero Power Behavior ===
        intake1.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);
        flywheelLeft.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        flywheelRight.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        frontLeftMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        frontRightMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        backLeftMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        backRightMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);

        // === Reset Encoders ===
        resetEncoders();

        telemetry.addLine("READY");
        telemetry.update();

        waitForStart();
        if (isStopRequested()) return;

        // === AUTON START (distances & speeds unchanged) ===

        driveForDistance(-72, 0.8);
        shootBall();

        TurnForAngle(-160, 0.7);

        intakeBall();

        driveForDistance(48, 1.0);

        TurnForAngle(125, 0.6);

        shootBall();

        TurnForAngle(-35, 0.6);

        driveForDistance(-6, 0.5);

        strafeForDistance(40, 0.8, false);
        strafeForDistance(40, 0.6, true);

        driveForDistance(-12, 0.6);

        TurnForAngle(-90, 0.7);

        intakeBall();

        driveForDistance(38, 1.0);

        TurnForAngle(125, 0.7);

        strafeForDistance(4, 0.5, true);

        shootBall();

        TurnForAngle(-35, 0.6);

        driveForDistance(-48, 0.6);

        TurnForAngle(-90, 0.6);

        intakeBall();

        driveForDistance(60, 0.7);

        TurnForAngle(125, 0.6);

        shootBall();

        TurnForAngle(-125, 0.6);

        intakeBall();

        driveForDistance(60, 0.7);

        TurnForAngle(125, 0.6);

        shootBall();

        TurnForAngle(-125, 0.6);

        intakeBall();

        driveForDistance(60, 0.7);

        TurnForAngle(125, 0.6);

        shootBall();

        driveForDistance(36, 0.8);

        stopMotors();
    }

    // =====================================================================
    // ======================= SUPPORTING METHODS ===========================
    // =====================================================================

    private void resetEncoders() {
        frontLeftMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        frontRightMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        backLeftMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        backRightMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);

        frontLeftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        frontRightMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        backLeftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        backRightMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    }

    // === Optimized shoot cycle (Option C timing) ===
    public void shootBall() {
        ElapsedTime t = new ElapsedTime();

        // Flywheel spin-up (reduced)
        flywheelLeft.setPower(-1);
        flywheelRight.setPower(-1);
        while (opModeIsActive() && t.seconds() < 0.25) {}

        // Feed
        t.reset();
        intake1.setPower(-0.5);
        intake2.setPower(-0.5);
        while (opModeIsActive() && t.seconds() < 1.5) {}

        // Stop
        intake1.setPower(0);
        intake2.setPower(0);
        flywheelLeft.setPower(0);
        flywheelRight.setPower(0);

        // Short pause
        t.reset();
        while (opModeIsActive() && t.seconds() < 0.2) {}
    }

    // === Optimized intake (Option C timing) ===
    public void intakeBall() {
        ElapsedTime t = new ElapsedTime();

        // Small pre-delay
        while (opModeIsActive() && t.seconds() < 0.1) {}

        // Intake + drive
        t.reset();
        frontLeftMotor.setPower(-0.6);
        frontRightMotor.setPower(-0.6);
        backLeftMotor.setPower(-0.6);
        backRightMotor.setPower(-0.6);
        intake1.setPower(-0.4);
        intake2.setPower(-0.4);

        while (opModeIsActive() && t.seconds() < 1.0) {}

        // Stop
        stopMotors();
        intake1.setPower(0);
        intake2.setPower(0);

        // Short post-delay
        t.reset();
        while (opModeIsActive() && t.seconds() < 0.2) {}
    }

    // === Encoder Turning ===
    public void TurnForAngle(double angleDegrees, double power) {
        double TRACK_WIDTH = 21.3028;
        double turnInches = Math.PI * TRACK_WIDTH * (angleDegrees / 360.0);
        int ticks = (int)(turnInches * TICKS_PER_INCH);

        frontLeftMotor.setTargetPosition(frontLeftMotor.getCurrentPosition() + ticks);
        backLeftMotor.setTargetPosition(backLeftMotor.getCurrentPosition() + ticks);
        frontRightMotor.setTargetPosition(frontRightMotor.getCurrentPosition() - ticks);
        backRightMotor.setTargetPosition(backRightMotor.getCurrentPosition() - ticks);

        frontLeftMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        backLeftMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        frontRightMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        backRightMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);

        frontLeftMotor.setPower(power);
        backLeftMotor.setPower(power);
        frontRightMotor.setPower(power);
        backRightMotor.setPower(power);

        while (opModeIsActive() &&
                frontLeftMotor.isBusy() && frontRightMotor.isBusy() &&
                backLeftMotor.isBusy() && backRightMotor.isBusy()) {}

        stopMotors();
    }

    // === Encoder Drive ===
    public void driveForDistance(double distanceInches, double power) {
        int ticks = (int)(distanceInches * TICKS_PER_INCH);

        frontLeftMotor.setTargetPosition(frontLeftMotor.getCurrentPosition() + ticks);
        backLeftMotor.setTargetPosition(backLeftMotor.getCurrentPosition() + ticks);
        frontRightMotor.setTargetPosition(frontRightMotor.getCurrentPosition() + ticks);
        backRightMotor.setTargetPosition(backRightMotor.getCurrentPosition() + ticks);

        frontLeftMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        backLeftMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        frontRightMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        backRightMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);

        frontLeftMotor.setPower(power);
        backLeftMotor.setPower(power);
        frontRightMotor.setPower(power);
        backRightMotor.setPower(power);

        while (opModeIsActive() &&
                frontLeftMotor.isBusy() && frontRightMotor.isBusy() &&
                backLeftMotor.isBusy() && backRightMotor.isBusy()) {}

        stopMotors();
    }

    // === Encoder Strafe ===
    public void strafeForDistance(double distanceInches, double power, boolean right) {
        int ticks = (int)(distanceInches * TICKS_PER_INCH);

        if (right) {
            frontLeftMotor.setTargetPosition(frontLeftMotor.getCurrentPosition() + ticks);
            backLeftMotor.setTargetPosition(backLeftMotor.getCurrentPosition() - ticks);
            frontRightMotor.setTargetPosition(frontRightMotor.getCurrentPosition() - ticks);
            backRightMotor.setTargetPosition(backRightMotor.getCurrentPosition() + ticks);
        } else {
            frontLeftMotor.setTargetPosition(frontLeftMotor.getCurrentPosition() - ticks);
            backLeftMotor.setTargetPosition(backLeftMotor.getCurrentPosition() + ticks);
            frontRightMotor.setTargetPosition(frontRightMotor.getCurrentPosition() + ticks);
            backRightMotor.setTargetPosition(backRightMotor.getCurrentPosition() - ticks);
        }

        frontLeftMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        backLeftMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        frontRightMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        backRightMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);

        frontLeftMotor.setPower(power);
        backLeftMotor.setPower(power);
        frontRightMotor.setPower(power);
        backRightMotor.setPower(power);

        while (opModeIsActive() &&
                frontLeftMotor.isBusy() && frontRightMotor.isBusy() &&
                backLeftMotor.isBusy() && backRightMotor.isBusy()) {}

        stopMotors();
    }

    // === Stop Motors ===
    private void stopMotors() {
        frontLeftMotor.setPower(0);
        frontRightMotor.setPower(0);
        backLeftMotor.setPower(0);
        backRightMotor.setPower(0);

        frontLeftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        frontRightMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        backLeftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        backRightMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    }
}
